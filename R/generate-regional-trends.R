#' Generate regional trends for countries, states/provinces, or BCRs from analyses run on the cws or usgs stratifications
#'
#' \code{generate_regional_trends} calculates the geometric mean annual changes in population size for composite regions.
#'
#' @param indices regional indices generated by \code{generate_regional_indices}
#' @param min_year Minimum year to calculate trends from
#' @param max_year Maximum year to calculate trends to
#' @param quantiles vector of quantiles to be sampled from the posterior distribution Defaults to c(0.025,0.05,0.25,0.5,0.75,0.95,0.975)
#' @param slope Logical, if TRUE, calculates an alternative trend metric, the slope of a log-linear regression through the annual indices. Default FALSE
#'
#' @return Numeric percentage of trend
#'
#' @examples
#'
#' \dontrun{
#' # Run a JAGS model analysis on a species
#' stratified_data <- stratify(bbs_data = fetch_bbs_data(), stratify_by = "bbs_usgs")
#' prepped_data <- prepare_jags_data(strat_data = stratified_data,
#'                                   species_to_run = "Wood Thrush",
#'                                   model = "slope")
#' mod <- run_model(jags_data = prepped_data)
#'
#' #Generate the annual indices for states/provinces, countries, and BCRs
#' regional_index <- generate_regional_indices(jags_mod = mod)
#'
#' #Output the trend
#' generate_regional_trends(indices = regional_index)
#' }
#'
#' @export
#'

generate_regional_trends <- function(indices = NULL,
                                Min_year = NULL,
                                Max_year = NULL,
                                quantiles = c(0.025,0.05,0.25,0.75,0.95,0.975),
                                slope = FALSE,
                                prob_decrease = NULL,
                                prob_increase = NULL)
{
  if (is.null(indices))
  {
    stop("No indices supplied to generate_regional_trends()."); return(NULL)
  }
  n_all = indices$samples

  if (is.null(Min_year))
  {
    min_year = indices$y_min
    Min_year <- indices$startyear
    minyn <- 1
  }else{
    min_year <- indices$y_min + (Min_year-indices$startyear)
    minyn <- 1 + (Min_year-indices$startyear)
  }
  if (is.null(Max_year))
  {
    max_year = indices$y_max
    Max_year = indices$startyear+(max_year - indices$y_min)
    maxyn <- 1+(indices$y_max-indices$y_min)
  }else{
    max_year <- indices$y_min + (Max_year-indices$startyear)
    maxyn <- 1+(Max_year-indices$startyear)
  }


regions = indices$regions
area_weights <- indices$area_weights

all_regions = names(n_all)
dsum = indices$data_summary

  # region_names <- utils::read.csv(system.file("composite-regions", strata[[stratify_by]], package = "bbsBayes"),stringsAsFactors = F)
  # region_names$region = factor(region_names$region,levels = levels(area_weights$region))
  #
trend <- data.frame(Start_year = integer(),
                    End_year = integer(),
                    Region = character(),
                    Region_alt = character(),
                    Region_type = character(),
                    Strata_included = character(),
                    Strata_excluded = character(),
                    Trend = double(),
                    stringsAsFactors = F)
for(qq in quantiles){
  trend[,paste0("Trend_Q",qq)] <- double()
}
trend[,"Percent_Change"] <- double()
for(qq in quantiles){
  trend[,paste0("Percent_Change_Q",qq)] <- double()
}



for(rr in regions){ #selecting the type of composite region
  for(rrs in all_regions[grep(all_regions,pattern = rr)]){


n = n_all[[rrs]]
reg = gsub(rrs,pattern = paste0(rr,"_"),replacement = "",fixed = T)
w_summary_rows = which(dsum$Region == reg & dsum$Region_type == rr)

reg_alt = unique(dsum[w_summary_rows,"Region_alt"])
st_inc = unique(dsum[w_summary_rows,"Strata_included"])
nstr = length(st_inc)
st_exc = unique(dsum[w_summary_rows,"Strata_excluded"])

  if(slope){

    bsl = function(i){
      n = length(wy)
      sy = sum(i)
      sx = sum(wy)
      ssx = sum(wy^2)
      sxy = sum(i*wy)
      b = (n*sxy - sx*sy)/(n*ssx - sx^2)
      return(b)
    }
    wy = c(minyn:maxyn)
    ne = log(n[,wy])
    m =  t(apply(ne,1,FUN = bsl))

    sl.t = as.vector((exp(m)-1)*100)

  }

  ch = n[,maxyn]/n[,minyn]
  tr = 100*((ch^(1/(maxyn-minyn)))-1)

  trendt <- data.frame(Start_year = (indices$startyear+minyn)-1,
                      End_year = (indices$startyear+maxyn)-1,
                      Region = reg,
                      Region_alt = reg_alt,
                      Region_type = rr,
                      Strata_included = st_inc,
                      Strata_excluded = st_exc,
                      Trend = median(tr),
                      stringsAsFactors = F)
  for(qq in quantiles){
    trendt[,paste0("Trend_Q",qq)] <- quantile(tr,qq,names = F)
  }

  ### estimated %change
  trendt[,"Percent_Change"] <- 100*(median(ch)-1)
  for(qq in quantiles){
    trendt[,paste0("Percent_Change_Q",qq)] <- 100*(quantile(ch,qq,names = F)-1)
  }

  ### optional slope based trends
  if(slope){
    trendt[,"Slope_Trend"] <- median(sl.t)
    for(qq in quantiles){
      trendt[,paste0("Slope_Trend_Q",qq)] <- quantile(sl.t,qq,names = F)
    }
  }

  #### model conditional probabilities of population change during trend period
  if(!is.null(prob_decrease)){
    pch = 100*(ch-1)
for(pp in prob_decrease){
  trendt[,paste0("prob_decrease > ",pp," percent")] <- length(pch[which(pch < (-1*pp))])/length(pch)
}
  }
  if(!is.null(prob_increase)){
    pch = 100*(ch-1)
    for(pp in prob_increase){
      trendt[,paste0("prob_increase > ",pp," percent")] <- length(pch[which(pch > (pp))])/length(pch)
    }
  }


  ###### reliability criteria
  trendt[,"Relative Abundance"] <- mean(dsum[w_summary_rows,"Index"])
  trendt[,"Observed Relative Abundance"] <- mean(dsum[w_summary_rows,"obs_mean"])
  trendt[,"Number of strata"] <- nstr
  q1 = quantiles[1]
  q2 = quantiles[length(quantiles)]
  trendt[,paste("Width of",(q2-q1)*100,"percent Credible Interval")] <- trendt[,paste0("Trend_Q",q2)]-trendt[,paste0("Trend_Q",q1)]
if(slope){
  trendt[,paste("Width of",(q2-q1)*100,"percent Credible Interval Slope")] <- trendt[,paste0("Slope_Trend_Q",q2)]-trendt[,paste0("Slope_Trend_Q",q1)]
}


  trend = rbind(trend,trendt)
  }
}
  return(trend)
}
